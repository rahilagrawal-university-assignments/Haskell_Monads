
==================== FINAL INTERFACE ====================
2019-08-04 03:01:37.241971 UTC

interface main@main:Tests.UnitTests 8002
  interface hash: 29437ed6d1cc8f1fb5355c06d8729feb
  ABI hash: f938176812b6ec968561ac411336219d
  export-list hash: 3daa4523bd99fa2d8034f9248244585b
  orphan hash: 0066f1fdf3afaaa82f77f8679d2e4bd3
  flag hash: d0974d33914cff3000166825e0614f6a
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tests.UnitTests.substring
  Tests.UnitTests.test_ch_1
  Tests.UnitTests.test_ch_2
  Tests.UnitTests.test_ch_3
  Tests.UnitTests.test_ch_4
  Tests.UnitTests.test_ch_5
  Tests.UnitTests.test_char_filter
  Tests.UnitTests.test_char_maybe
  Tests.UnitTests.test_empty_list
  Tests.UnitTests.test_empty_maybe
  Tests.UnitTests.test_fail_list
  Tests.UnitTests.test_fail_maybe
  Tests.UnitTests.test_seq_1
  Tests.UnitTests.test_seq_2
  Tests.UnitTests.test_seq_3
  Tests.UnitTests.test_seq_4
  Tests.UnitTests.test_seq_5
  Tests.UnitTests.test_star_1
  Tests.UnitTests.test_star_2
  Tests.UnitTests.test_star_3
module dependencies: Hare HareMonad
package dependencies: QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu
                      ansi-terminal-0.6.3.1@ansi-terminal-0.6.3.1-3RTqikoQf47ajVD9m8zgB
                      ansi-wl-pprint-0.6.7.3@ansi-wl-pprint-0.6.7.3-A79v826bgPr574HtaZPPqC
                      array-0.5.1.1@array-0.5.1.1
                      async-2.1.1.1@async-2.1.1.1-8yywY4inVGRLJSCg60gBXj base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      clock-0.7.2@clock-0.7.2-8dRNleB7rysIZAOReuhpZA
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-boot-th-8.0.2@ghc-boot-th-8.0.2
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      optparse-applicative-0.13.2.0@optparse-applicative-0.13.2.0-EqIYOWOFTvf23sT5QTYn9U
                      parsec-3.1.11@parsec-3.1.11-1aqiimsgq2dCv7eoaC8WuX
                      pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      process-1.4.3.0@process-1.4.3.0
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      regex-base-0.93.2@regex-base-0.93.2-AYjYAsBidAc8f5XNm9b2Aa
                      regex-tdfa-1.2.2@regex-tdfa-1.2.2-CuFri6F1SLwFkkN6cPEwX5
                      stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      tasty-0.11.3@tasty-0.11.3-70FgRohyKVSBrTVBDiKym5
                      tasty-quickcheck-0.8.4@tasty-quickcheck-0.8.4-6yX5MsaPsBs85Fll2R9pO0
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      tf-random-0.5@tf-random-0.5-CJZw1ZWS5MOJlR60HqKEZL
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      unbounded-delays-0.1.1.0@unbounded-delays-0.1.1.0-8pvOsE97fmS7WDAN5vUbqX
                      unix-2.7.2.1@unix-2.7.2.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         regex-base-0.93.2@regex-base-0.93.2-AYjYAsBidAc8f5XNm9b2Aa:Text.Regex.Base.Context
         regex-tdfa-1.2.2@regex-tdfa-1.2.2-CuFri6F1SLwFkkN6cPEwX5:Text.Regex.TDFA.ByteString
         regex-tdfa-1.2.2@regex-tdfa-1.2.2-CuFri6F1SLwFkkN6cPEwX5:Text.Regex.TDFA.ByteString.Lazy
         regex-tdfa-1.2.2@regex-tdfa-1.2.2-CuFri6F1SLwFkkN6cPEwX5:Text.Regex.TDFA.Sequence
         regex-tdfa-1.2.2@regex-tdfa-1.2.2-CuFri6F1SLwFkkN6cPEwX5:Text.Regex.TDFA.String
         stm-2.4.4.1@stm-2.4.4.1-JQn4hNPyYjP5m9AcbI88Ve:Control.Monad.STM
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         clock-0.7.2@clock-0.7.2-8dRNleB7rysIZAOReuhpZA:System.Clock
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         tasty-0.11.3@tasty-0.11.3-70FgRohyKVSBrTVBDiKym5:Test.Tasty.Core
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  Hare 049d962a2e46f212978221b8bee13ec3
  exports: 3f0d67ee01e33a7610568b1d92b67a2e
  =~ fecae3fa21091bc622f47760f10b2d2d
  Char e398ed7ae80d873cc0ab855976960f98
  Choose 71c1b001856810c6a9dbeaf7c71fade6
  Empty dcbc5fe7c00b84aec286fcdf1ad29000
  Fail cb873987642943b9ca3d0016c10dcc98
  Seq 7cadc1bd046c61aeb71552ed8bd31603
  Star 577d5433495ac7fc97fe684cde829ba7
import  -/  tasty-quickcheck-0.8.4@tasty-quickcheck-0.8.4-6yX5MsaPsBs85Fll2R9pO0:Test.Tasty.QuickCheck 66e19512020212394375b5a95f95146f
4831fd5c38422566407a35f0e6cf44c2
  $s$fArbitrary[]_$s$fArbitrary[]_$cshrink ::
    [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (xs :: [GHC.Types.Char]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ GHC.Types.Char
                   Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
                   xs) -}
3f9599e97196b1c7c88873fe7f6bbb3d
  $s$fEq(,) :: GHC.Classes.Eq ((), GHC.Types.Char)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ((), GHC.Types.Char)
                  (GHC.Classes.$fEq(,)_$c==
                     @ ()
                     @ GHC.Types.Char
                     GHC.Classes.$fEq()
                     GHC.Classes.$fEqChar)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ ()
                     @ GHC.Types.Char
                     GHC.Classes.$fEq()
                     GHC.Classes.$fEqChar) -}
25ccad789440488e52de99f758d9545d
  $s$fEq(,)1 :: GHC.Classes.Eq (GHC.Types.Char, ())
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Char, ())
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Char
                     @ ()
                     GHC.Classes.$fEqChar
                     GHC.Classes.$fEq())
                  (GHC.Classes.$fEq(,)_$c/=
                     @ GHC.Types.Char
                     @ ()
                     GHC.Classes.$fEqChar
                     GHC.Classes.$fEq()) -}
5f67962653fece6a6748c88b96987d13
  $s$fEq(,)2 :: GHC.Classes.Eq (GHC.Types.Char, GHC.Types.Char)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Char, GHC.Types.Char)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     GHC.Classes.$fEqChar
                     GHC.Classes.$fEqChar)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     GHC.Classes.$fEqChar
                     GHC.Classes.$fEqChar) -}
02e9220893a2e4b8ef0946449b093e82
  $s$fEq[] :: GHC.Classes.Eq [()]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [()]
                  (GHC.Classes.$fEq[]_$c== @ () GHC.Classes.$fEq())
                  Tests.UnitTests.$s$fEq[]_$s$fEq[]_$c/= -}
5fa30f8139ca82e445bd96d417b0f310
  $s$fEq[]_$s$fEq[]_$c/= :: [()] -> [()] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: [()]) (y :: [()]) ->
                 GHC.Classes.not
                   (GHC.Classes.$fEq[]_$c== @ () GHC.Classes.$fEq() x y)) -}
98d744d5683c146ab6b1eec7f2835a25
  $stestProperty10 ::
    (GHC.Types.Char -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3, Strictness: <L,C(U)><L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (f :: GHC.Types.Char -> GHC.Types.Bool)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ GHC.Types.Char
                   @ GHC.Types.Bool
                   GHC.Show.$fShowChar
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitraryChar1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Char>_R))
                   Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
                   f
                   eta
                   eta1) -}
3b44dab10be1636dfbdf2a556a8eb7a9
  $stestProperty2 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int)[OneShot] ->
                 case eta1 of ww { GHC.Types.I# ww1 ->
                 Test.QuickCheck.Gen.$wlistOf
                   @ GHC.Types.Char
                   Test.QuickCheck.Arbitrary.$fArbitraryChar1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Char>_R))
                   eta
                   ww1 }) -}
9ba45eeb1eef5d09eeab7c772bc7aac0
  $stestProperty3 ::
    ([GHC.Types.Char]
     -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3, Strictness: <L,C(U)><L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (f :: [GHC.Types.Char]
                         -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty4
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   f
                   eta
                   eta1) -}
2d9a9e69419533db68911ff3ba1ad51f
  $stestProperty4 ::
    ([GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3, Strictness: <L,C(U)><L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (f :: [GHC.Types.Char]
                         -> [GHC.Types.Char] -> GHC.Types.Bool)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   f
                   eta
                   eta1) -}
0409ffbd4bb412578e26198b5ab83dc6
  $stestProperty5 ::
    ([GHC.Types.Char] -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3, Strictness: <L,C(U)><L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (f :: [GHC.Types.Char] -> GHC.Types.Bool)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ GHC.Types.Bool
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   f
                   eta
                   eta1) -}
817174bb68285c7edfc0b057e7652bc5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Tests.UnitTests.$trModule2
                   Tests.UnitTests.$trModule1) -}
7a3730691fe7ef5bd8ae9ab81896ced8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tests.UnitTests"#) -}
dc4535bf6b4ac13b738f4a714fb9325e
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
ba8ebf66b172f15c40e7abf9ed365c61
  $wxs :: GHC.Prim.Int# -> [()]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
011e3a85d38314a0bc0dc773f92c3928
  $wxs1 :: GHC.Prim.Int# -> [[()]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
a9a2bf01b636e3ad9115ef33b3fc2348
  substring :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (x :: GHC.Base.String) (y :: GHC.Base.String) ->
                 letrec {
                   tailsGo :: [GHC.Types.Char] -> Data.Monoid.Any
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (xs :: [GHC.Types.Char]) ->
                     case Data.OldList.isPrefixOf
                            @ GHC.Types.Char
                            GHC.Classes.$fEqChar
                            x
                            xs of wild {
                       GHC.Types.False
                       -> case xs of wild1 {
                            [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                            : ds xs' -> tailsGo xs' }
                       GHC.Types.True
                       -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) }
                 } in
                 (tailsGo y) `cast` (Data.Monoid.N:Any[0])) -}
da34e96f8ce4ced61268aa10a558879f
  test_ch_1 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_ch_8
                   Tests.UnitTests.test_ch_7
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
8352bba796a6f30901360482e0fc61fe
  test_ch_10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fail in choose 2"#) -}
16381860ebe2da78ea9e5d12a603ed07
  test_ch_11 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty4
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_ch_3_f
                   eta
                   eta1) -}
678e1ea06fa23027b7b04ff5ea410166
  test_ch_12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "two chars in choose"#) -}
c998d788e9e2bffc391d38a52ddac989
  test_ch_13 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char]
                      -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty3
                     `cast`
                   (Trans
                        (<[GHC.Types.Char]
                          -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char]
                                   -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_ch_4_f
                   eta
                   eta1) -}
458af4ea78484d070356eaf3d6c61eb4
  test_ch_14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "choose and seq 1"#) -}
cf6725e0f9b084856fae519baae9951a
  test_ch_15 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char]
                      -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty3
                     `cast`
                   (Trans
                        (<[GHC.Types.Char]
                          -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char]
                                   -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_ch_5_f
                   eta
                   eta1) -}
a19a82860ce6ffd53147901801051e86
  test_ch_16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "choose and seq 2"#) -}
082a642636491e48ea5b8e113774a714
  test_ch_1_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: [GHC.Types.Char]) ->
                 GHC.Base.eqString
                   (GHC.Base.map
                      @ (GHC.Base.String, GHC.Types.Char)
                      @ GHC.Types.Char
                      (Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char)
                      ((Hare.matchAnywhere
                          @ []
                          @ GHC.Types.Char
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <GHC.Types.Char>_N)
                         s))
                   (GHC.Base.map
                      @ (GHC.Base.String, GHC.Types.Char)
                      @ GHC.Types.Char
                      (Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char)
                      ((Hare.matchAnywhere
                          @ []
                          @ GHC.Types.Char
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Choose
                             @ GHC.Types.Char
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c)
                             (Hare.Fail @ GHC.Types.Char)))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <GHC.Types.Char>_N)
                         s))) -}
abd71dc2bef71a5def7c21e2e4ce3be3
  test_ch_2 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_ch_10
                   Tests.UnitTests.test_ch_9
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
6b29672e852a7d65da46a2482d767d3d
  test_ch_2_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: [GHC.Types.Char]) ->
                 GHC.Base.eqString
                   (GHC.Base.map
                      @ (GHC.Base.String, GHC.Types.Char)
                      @ GHC.Types.Char
                      (Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char)
                      ((Hare.matchAnywhere
                          @ []
                          @ GHC.Types.Char
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <GHC.Types.Char>_N)
                         s))
                   (GHC.Base.map
                      @ (GHC.Base.String, GHC.Types.Char)
                      @ GHC.Types.Char
                      (Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char)
                      ((Hare.matchAnywhere
                          @ []
                          @ GHC.Types.Char
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Choose
                             @ GHC.Types.Char
                             (Hare.Fail @ GHC.Types.Char)
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c)))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <GHC.Types.Char>_N)
                         s))) -}
dff4f9cd939f850a2076b7dad335782f
  test_ch_3 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_ch_12
                   Tests.UnitTests.test_ch_11
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
c6abb97747e74bd42ca9910fa751c4cd
  test_ch_3_f ::
    [GHC.Types.Char]
    -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (c1 :: [GHC.Types.Char])
                   (c2 :: [GHC.Types.Char]) ->
                 let {
                   ds1 :: GHC.Base.Maybe GHC.Types.Char
                   = case (Hare.matchAnywhere
                             @ GHC.Base.Maybe
                             @ GHC.Types.Char
                             GHC.Base.$fAlternativeMaybe
                             GHC.Base.$fMonadMaybe
                             (Hare.Char
                                @ GHC.Types.Char
                                @~ <GHC.Types.Char>_N
                                (GHC.Base.++ @ GHC.Types.Char c1 c2)))
                            `cast`
                          (HareMonad.N:Hare[0] <GHC.Base.Maybe>_R <GHC.Types.Char>_N)
                            s of wild {
                       GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Char
                       GHC.Base.Just x
                       -> GHC.Base.Just
                            @ GHC.Types.Char
                            (Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char x) }
                 } in
                 case (Hare.matchAnywhere
                         @ GHC.Base.Maybe
                         @ GHC.Types.Char
                         GHC.Base.$fAlternativeMaybe
                         GHC.Base.$fMonadMaybe
                         (Hare.Choose
                            @ GHC.Types.Char
                            (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1)
                            (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c2)))
                        `cast`
                      (HareMonad.N:Hare[0] <GHC.Base.Maybe>_R <GHC.Types.Char>_N)
                        s of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just x
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1
                        -> case x of wild2 { (,) ds2 y -> GHC.Classes.eqChar y b1 } } }) -}
b96df43c899e5ff9eba6c897adaad4a6
  test_ch_4 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_ch_14
                   Tests.UnitTests.test_ch_13
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
0a09bf2b191e88ae06ba690d2c49fbcd
  test_ch_4_f ::
    [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (c1 :: [GHC.Types.Char])
                   (c2 :: [GHC.Types.Char])
                   (c3 :: [GHC.Types.Char]) ->
                 GHC.Classes.$fEq[]_$c==
                   @ (GHC.Types.Char, GHC.Types.Char)
                   Tests.UnitTests.$s$fEq(,)2
                   (GHC.Base.map
                      @ (GHC.Base.String, (GHC.Types.Char, GHC.Types.Char))
                      @ (GHC.Types.Char, GHC.Types.Char)
                      (Data.Tuple.snd
                         @ GHC.Base.String
                         @ (GHC.Types.Char, GHC.Types.Char))
                      ((Hare.matchAnywhere
                          @ []
                          @ (GHC.Types.Char, GHC.Types.Char)
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Seq
                             @ (GHC.Types.Char, GHC.Types.Char)
                             @ GHC.Types.Char
                             @ GHC.Types.Char
                             @~ <(GHC.Types.Char, GHC.Types.Char)>_N
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1)
                             (Hare.Choose
                                @ GHC.Types.Char
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c2)
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c3))))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <(GHC.Types.Char, GHC.Types.Char)>_N)
                         s))
                   (GHC.Base.map
                      @ (GHC.Base.String, (GHC.Types.Char, GHC.Types.Char))
                      @ (GHC.Types.Char, GHC.Types.Char)
                      (Data.Tuple.snd
                         @ GHC.Base.String
                         @ (GHC.Types.Char, GHC.Types.Char))
                      ((Hare.matchAnywhere
                          @ []
                          @ (GHC.Types.Char, GHC.Types.Char)
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Choose
                             @ (GHC.Types.Char, GHC.Types.Char)
                             (Hare.Seq
                                @ (GHC.Types.Char, GHC.Types.Char)
                                @ GHC.Types.Char
                                @ GHC.Types.Char
                                @~ <(GHC.Types.Char, GHC.Types.Char)>_N
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1)
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c2))
                             (Hare.Seq
                                @ (GHC.Types.Char, GHC.Types.Char)
                                @ GHC.Types.Char
                                @ GHC.Types.Char
                                @~ <(GHC.Types.Char, GHC.Types.Char)>_N
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1)
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c3))))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <(GHC.Types.Char, GHC.Types.Char)>_N)
                         s))) -}
7e1d11e2ddece67fd45f4746113e2994
  test_ch_5 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_ch_16
                   Tests.UnitTests.test_ch_15
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
eacdd67bd3b032d5355b43be25c8eb8d
  test_ch_5_f ::
    [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (c1 :: [GHC.Types.Char])
                   (c2 :: [GHC.Types.Char])
                   (c3 :: [GHC.Types.Char]) ->
                 GHC.Classes.$fEq[]_$c==
                   @ (GHC.Types.Char, GHC.Types.Char)
                   Tests.UnitTests.$s$fEq(,)2
                   (GHC.Base.map
                      @ (GHC.Base.String, (GHC.Types.Char, GHC.Types.Char))
                      @ (GHC.Types.Char, GHC.Types.Char)
                      (Data.Tuple.snd
                         @ GHC.Base.String
                         @ (GHC.Types.Char, GHC.Types.Char))
                      ((Hare.matchAnywhere
                          @ []
                          @ (GHC.Types.Char, GHC.Types.Char)
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Seq
                             @ (GHC.Types.Char, GHC.Types.Char)
                             @ GHC.Types.Char
                             @ GHC.Types.Char
                             @~ <(GHC.Types.Char, GHC.Types.Char)>_N
                             (Hare.Choose
                                @ GHC.Types.Char
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c2)
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c3))
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1)))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <(GHC.Types.Char, GHC.Types.Char)>_N)
                         s))
                   (GHC.Base.map
                      @ (GHC.Base.String, (GHC.Types.Char, GHC.Types.Char))
                      @ (GHC.Types.Char, GHC.Types.Char)
                      (Data.Tuple.snd
                         @ GHC.Base.String
                         @ (GHC.Types.Char, GHC.Types.Char))
                      ((Hare.matchAnywhere
                          @ []
                          @ (GHC.Types.Char, GHC.Types.Char)
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Choose
                             @ (GHC.Types.Char, GHC.Types.Char)
                             (Hare.Seq
                                @ (GHC.Types.Char, GHC.Types.Char)
                                @ GHC.Types.Char
                                @ GHC.Types.Char
                                @~ <(GHC.Types.Char, GHC.Types.Char)>_N
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c2)
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1))
                             (Hare.Seq
                                @ (GHC.Types.Char, GHC.Types.Char)
                                @ GHC.Types.Char
                                @ GHC.Types.Char
                                @~ <(GHC.Types.Char, GHC.Types.Char)>_N
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c3)
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1))))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <(GHC.Types.Char, GHC.Types.Char)>_N)
                         s))) -}
248747ddd26e695dd95b0d94877fc399
  test_ch_7 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_ch_1_f
                   eta
                   eta1) -}
b45ccd5715f74a4728961372e346efca
  test_ch_8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fail in choose 1"#) -}
7e497d1dbcbf91c209617e0e6722d84a
  test_ch_9 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_ch_2_f
                   eta
                   eta1) -}
294e3e0866970f878d39fae03c8e45b0
  test_char_filter :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_char_filter2
                   Tests.UnitTests.test_char_filter1
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
c76d0a9672529ce5f2879bab6ad99840
  test_char_filter1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_char_filter_f
                   eta
                   eta1) -}
540aecde057670715f5d60b8928eccd1
  test_char_filter2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "char (list) is like filter"#) -}
03da1069700d3f966de09d932042e240
  test_char_filter_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (xs :: [GHC.Types.Char]) ->
                 GHC.Base.eqString
                   (GHC.Base.map
                      @ (GHC.Base.String, GHC.Types.Char)
                      @ GHC.Types.Char
                      (Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char)
                      ((Hare.matchAnywhere
                          @ []
                          @ GHC.Types.Char
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N xs))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <GHC.Types.Char>_N)
                         s))
                   (GHC.List.filter
                      @ GHC.Types.Char
                      (\ (ds :: GHC.Types.Char) ->
                       GHC.List.elem @ GHC.Types.Char GHC.Classes.$fEqChar ds xs)
                      s)) -}
5c1e171d7488f0783b284d4da692539b
  test_char_maybe :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_char_maybe2
                   Tests.UnitTests.test_char_maybe1
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
c76eb3868828727a15c7fc782cb4611d
  test_char_maybe1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ (GHC.Types.Char -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty10
                     `cast`
                   (Trans
                        (<GHC.Types.Char -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <GHC.Types.Char -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_char_maybe_f
                   eta
                   eta1) -}
1e28246d8d582cea443d658535805a11
  test_char_maybe2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "char (maybe)"#) -}
30c6d57ddb26eb1801715faa3ecfa249
  test_char_maybe_f ::
    [GHC.Types.Char] -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: GHC.Types.Char) ->
                 case (Hare.matchAnywhere
                         @ GHC.Base.Maybe
                         @ GHC.Types.Char
                         GHC.Base.$fAlternativeMaybe
                         GHC.Base.$fMonadMaybe
                         (Hare.Char
                            @ GHC.Types.Char
                            @~ <GHC.Types.Char>_N
                            (GHC.Types.: @ GHC.Types.Char c (GHC.Types.[] @ GHC.Types.Char))))
                        `cast`
                      (HareMonad.N:Hare[0] <GHC.Base.Maybe>_R <GHC.Types.Char>_N)
                        s of wild {
                   GHC.Base.Nothing
                   -> case GHC.List.elem
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             c
                             s of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False }
                   GHC.Base.Just x
                   -> case x of wild1 { (,) ds1 y ->
                      case y of wild2 { GHC.Types.C# x1 ->
                      case c of wild3 { GHC.Types.C# y1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqChar# x1 y1) of wild4 {
                        GHC.Types.False
                        -> case GHC.List.elem
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqChar
                                  wild3
                                  s of wild5 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        GHC.Types.True
                        -> GHC.List.elem
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             wild3
                             s } } } } }) -}
6a62ff43c9d210a618f87ea13b5e4f09
  test_empty_list :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_empty_list2
                   Tests.UnitTests.test_empty_list1
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
877a4828817e2947c2b4a0b8775026f4
  test_empty_list1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ GHC.Types.Bool
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_empty_list_f
                   eta
                   eta1) -}
992d55cd622efeb513dc7d07489a6b90
  test_empty_list2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "empty (list)"#) -}
fce30f7eeec8013bc087c490048d88c9
  test_empty_list_f :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.+# ww2 1#
                 } in
                 let {
                   arg :: [()]
                   = GHC.Base.map
                       @ (GHC.Base.String, ())
                       @ ()
                       (Data.Tuple.snd @ GHC.Base.String @ ())
                       ((Hare.matchAnywhere
                           @ []
                           @ ()
                           GHC.Base.$fAlternative[]
                           GHC.Base.$fMonad[]
                           Hare.$WEmpty)
                          `cast`
                        (HareMonad.N:Hare[0] <[]>_R <()>_N)
                          s)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# y) of wild {
                   GHC.Types.False
                   -> GHC.Classes.$fEq[]_$c==
                        @ ()
                        GHC.Classes.$fEq()
                        arg
                        (GHC.Types.[] @ ())
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ ()
                        GHC.Classes.$fEq()
                        arg
                        (Tests.UnitTests.$wxs y) } }) -}
0cdd08636495183a85e08e8b419fc379
  test_empty_maybe :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_empty_maybe2
                   Tests.UnitTests.test_empty_maybe1
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
430dc77b58504447497adf14713da78c
  test_empty_maybe1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ GHC.Types.Bool
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_empty_maybe_f
                   eta
                   eta1) -}
4cb44999b61266c1e2479609711f57a6
  test_empty_maybe2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "empty (maybe)"#) -}
1bac5f9ccf3b315fef604632b8a33b8a
  test_empty_maybe_f :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case (Hare.matchAnywhere
                         @ GHC.Base.Maybe
                         @ ()
                         GHC.Base.$fAlternativeMaybe
                         GHC.Base.$fMonadMaybe
                         Hare.$WEmpty)
                        `cast`
                      (HareMonad.N:Hare[0] <GHC.Base.Maybe>_R <()>_N)
                        s of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just x
                   -> case x of wild1 { (,) ds1 y ->
                      case y of wild2 { () -> GHC.Types.True } } }) -}
918a89390783a7967c4f18521f9058dc
  test_fail_list :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_fail_list2
                   Tests.UnitTests.test_fail_list1
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
652e088b02cdad83f733c526ca7f577f
  test_fail_list1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ GHC.Types.Bool
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_fail_list_f
                   eta
                   eta1) -}
3a6731756e79d352f101c38d9e7b1735
  test_fail_list2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fail (list)"#) -}
c8098a60258da186af25457b03ac8ec6
  test_fail_list_f :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 GHC.Classes.$fEq[]_$c==
                   @ ()
                   GHC.Classes.$fEq()
                   (GHC.Base.map
                      @ (GHC.Base.String, ())
                      @ ()
                      (Data.Tuple.snd @ GHC.Base.String @ ())
                      ((Hare.matchAnywhere
                          @ []
                          @ ()
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Fail @ ()))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <()>_N)
                         s))
                   (GHC.Types.[] @ ())) -}
81e9f95d48dbf4b8da8699392864200a
  test_fail_maybe :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_fail_maybe2
                   Tests.UnitTests.test_fail_maybe1
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
a16e1a8201033db98e3374074388ec7e
  test_fail_maybe1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ GHC.Types.Bool
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_fail_maybe_f
                   eta
                   eta1) -}
99de01d098a980f55080c11ebc0cb7e8
  test_fail_maybe2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fail (maybe)"#) -}
6f8532487161e83518ce5bdf7c8b7b69
  test_fail_maybe_f :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Base.String) ->
                 case (Hare.matchAnywhere
                         @ GHC.Base.Maybe
                         @ ()
                         GHC.Base.$fAlternativeMaybe
                         GHC.Base.$fMonadMaybe
                         (Hare.Fail @ ()))
                        `cast`
                      (HareMonad.N:Hare[0] <GHC.Base.Maybe>_R <()>_N)
                        s of wild {
                   GHC.Base.Nothing -> GHC.Types.True
                   GHC.Base.Just x -> GHC.Types.False }) -}
2d8a6597403570e9281ec540cb0dad10
  test_seq_1 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_seq_8
                   Tests.UnitTests.test_seq_7
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
7a08d76104a4d3ae8a291c231df36f61
  test_seq_10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fail in seq 2"#) -}
6af02516a311a618a95791e8b6a8ab5a
  test_seq_11 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_seq_3_f
                   eta
                   eta1) -}
93a437b6367ace189816e8bb1d3125c4
  test_seq_12 ::
    (GHC.Base.String, GHC.Types.Char) -> ((), GHC.Types.Char)
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ (x :: (GHC.Base.String, GHC.Types.Char)) ->
                 (GHC.Tuple.(),
                  Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char x)) -}
aa092a6386a34606fefbb402fcbc29c2
  test_seq_13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "empty in seq 1"#) -}
8396398b70bedee79ef9cc7999934923
  test_seq_14 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_seq_4_f
                   eta
                   eta1) -}
d4f7888b1ab919880c9dfcc057326c5f
  test_seq_15 ::
    (GHC.Base.String, GHC.Types.Char) -> (GHC.Types.Char, ())
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ (x :: (GHC.Base.String, GHC.Types.Char)) ->
                 (Data.Tuple.snd @ GHC.Base.String @ GHC.Types.Char x,
                  GHC.Tuple.())) -}
aa52330bc5d4ea634086df3cba317d17
  test_seq_16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "empty in seq 2"#) -}
fda3541bd5e0bce98e25b7a65e2693d1
  test_seq_17 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty4
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_seq_5_f
                   eta
                   eta1) -}
5fefc5d8e4e012bac68799434c430f60
  test_seq_18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "two chars in seq"#) -}
782601fcbc8df7655022793a95daa6a2
  test_seq_1_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: [GHC.Types.Char]) ->
                 GHC.Classes.$fEq[]_$c==
                   @ ((), GHC.Types.Char)
                   Tests.UnitTests.$s$fEq(,)
                   (GHC.Base.map
                      @ (GHC.Base.String, ((), GHC.Types.Char))
                      @ ((), GHC.Types.Char)
                      (Data.Tuple.snd @ GHC.Base.String @ ((), GHC.Types.Char))
                      ((Hare.matchAnywhere
                          @ []
                          @ ((), GHC.Types.Char)
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Seq
                             @ ((), GHC.Types.Char)
                             @ ()
                             @ GHC.Types.Char
                             @~ <((), GHC.Types.Char)>_N
                             (Hare.Fail @ ())
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c)))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <((), GHC.Types.Char)>_N)
                         s))
                   (GHC.Types.[] @ ((), GHC.Types.Char))) -}
99ada22e1fdeb3709599f8c4d0d8ca09
  test_seq_2 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_seq_10
                   Tests.UnitTests.test_seq_9
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
9dba85c2e16a4a2be7c46c8350e29136
  test_seq_2_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: [GHC.Types.Char]) ->
                 GHC.Classes.$fEq[]_$c==
                   @ (GHC.Types.Char, ())
                   Tests.UnitTests.$s$fEq(,)1
                   (GHC.Base.map
                      @ (GHC.Base.String, (GHC.Types.Char, ()))
                      @ (GHC.Types.Char, ())
                      (Data.Tuple.snd @ GHC.Base.String @ (GHC.Types.Char, ()))
                      ((Hare.matchAnywhere
                          @ []
                          @ (GHC.Types.Char, ())
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Seq
                             @ (GHC.Types.Char, ())
                             @ GHC.Types.Char
                             @ ()
                             @~ <(GHC.Types.Char, ())>_N
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c)
                             (Hare.Fail @ ())))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <(GHC.Types.Char, ())>_N)
                         s))
                   (GHC.Types.[] @ (GHC.Types.Char, ()))) -}
4d27f1307dd81aba6ef153212ec276df
  test_seq_3 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_seq_13
                   Tests.UnitTests.test_seq_11
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
d17c52b398823e8feb56de263270d7d6
  test_seq_3_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: [GHC.Types.Char]) ->
                 GHC.Classes.$fEq[]_$c==
                   @ ((), GHC.Types.Char)
                   Tests.UnitTests.$s$fEq(,)
                   (GHC.Base.map
                      @ (GHC.Base.String, ((), GHC.Types.Char))
                      @ ((), GHC.Types.Char)
                      (Data.Tuple.snd @ GHC.Base.String @ ((), GHC.Types.Char))
                      ((Hare.matchAnywhere
                          @ []
                          @ ((), GHC.Types.Char)
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Seq
                             @ ((), GHC.Types.Char)
                             @ ()
                             @ GHC.Types.Char
                             @~ <((), GHC.Types.Char)>_N
                             Hare.$WEmpty
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c)))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <((), GHC.Types.Char)>_N)
                         s))
                   (GHC.Base.map
                      @ (GHC.Base.String, GHC.Types.Char)
                      @ ((), GHC.Types.Char)
                      Tests.UnitTests.test_seq_12
                      ((Hare.matchAnywhere
                          @ []
                          @ GHC.Types.Char
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <GHC.Types.Char>_N)
                         s))) -}
d5377dd8218b53d174a28ab596934449
  test_seq_4 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_seq_16
                   Tests.UnitTests.test_seq_14
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
502c6011b2348f5621cc62962247997a
  test_seq_4_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: [GHC.Types.Char]) ->
                 GHC.Classes.$fEq[]_$c==
                   @ (GHC.Types.Char, ())
                   Tests.UnitTests.$s$fEq(,)1
                   (GHC.Base.map
                      @ (GHC.Base.String, (GHC.Types.Char, ()))
                      @ (GHC.Types.Char, ())
                      (Data.Tuple.snd @ GHC.Base.String @ (GHC.Types.Char, ()))
                      ((Hare.matchAnywhere
                          @ []
                          @ (GHC.Types.Char, ())
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Seq
                             @ (GHC.Types.Char, ())
                             @ GHC.Types.Char
                             @ ()
                             @~ <(GHC.Types.Char, ())>_N
                             (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c)
                             Hare.$WEmpty))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <(GHC.Types.Char, ())>_N)
                         s))
                   (GHC.Base.map
                      @ (GHC.Base.String, GHC.Types.Char)
                      @ (GHC.Types.Char, ())
                      Tests.UnitTests.test_seq_15
                      ((Hare.matchAnywhere
                          @ []
                          @ GHC.Types.Char
                          GHC.Base.$fAlternative[]
                          GHC.Base.$fMonad[]
                          (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c))
                         `cast`
                       (HareMonad.N:Hare[0] <[]>_R <GHC.Types.Char>_N)
                         s))) -}
d88cf3cc7cfdc2cb677e792a6680b35b
  test_seq_5 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_seq_18
                   Tests.UnitTests.test_seq_17
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
45275da71ba1107c86a370d5bb20d0e4
  test_seq_5_f ::
    [GHC.Types.Char]
    -> [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String)
                   (c1 :: [GHC.Types.Char])
                   (c2 :: [GHC.Types.Char]) ->
                 case (Hare.matchAnywhere
                         @ GHC.Base.Maybe
                         @ (GHC.Types.Char, GHC.Types.Char)
                         GHC.Base.$fAlternativeMaybe
                         GHC.Base.$fMonadMaybe
                         (Hare.Seq
                            @ (GHC.Types.Char, GHC.Types.Char)
                            @ GHC.Types.Char
                            @ GHC.Types.Char
                            @~ <(GHC.Types.Char, GHC.Types.Char)>_N
                            (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c1)
                            (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c2)))
                        `cast`
                      (HareMonad.N:Hare[0]
                           <GHC.Base.Maybe>_R <(GHC.Types.Char, GHC.Types.Char)>_N)
                        s of wild {
                   GHC.Base.Nothing
                   -> letrec {
                        go :: [GHC.Types.Char] -> Data.Monoid.Any
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [GHC.Types.Char]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                            : y ys
                            -> let {
                                 z :: Data.Monoid.Any = go ys
                               } in
                               letrec {
                                 go1 :: [GHC.Types.Char] -> Data.Monoid.Any
                                   {- Arity: 1, Strictness: <S,1*U> -}
                                 = \ (ds1 :: [GHC.Types.Char]) ->
                                   case ds1 of wild2 {
                                     [] -> z
                                     : y1 ys1
                                     -> case Tests.UnitTests.substring
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  y
                                                  (GHC.Types.:
                                                     @ GHC.Types.Char
                                                     y1
                                                     (GHC.Types.[] @ GHC.Types.Char)))
                                               s of wild3 {
                                          GHC.Types.False -> go1 ys1
                                          GHC.Types.True
                                          -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } }
                               } in
                               go1 c2 }
                      } in
                      case (go c1) `cast` (Data.Monoid.N:Any[0]) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False }
                   GHC.Base.Just x
                   -> case x of wild1 { (,) ds1 y ->
                      case y of wild2 { (,) a b ->
                      Tests.UnitTests.substring
                        (GHC.Types.:
                           @ GHC.Types.Char
                           a
                           (GHC.Types.: @ GHC.Types.Char b (GHC.Types.[] @ GHC.Types.Char)))
                        s } } }) -}
778e4e3ebfcd1f114e880faa5a606173
  test_seq_7 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_seq_1_f
                   eta
                   eta1) -}
435fd5a7d8d94e50ddd3407bbb70ee12
  test_seq_8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fail in seq 1"#) -}
434cc3676e4857a540da979b9c0da755
  test_seq_9 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_seq_2_f
                   eta
                   eta1) -}
7d2476fb077017934e567f0dbaf16a06
  test_star_1 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_star_5
                   Tests.UnitTests.test_star_4
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
56ef29ccd26cd9f4b423883ccb6935c9
  test_star_10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "star char"#) -}
cf3fabb7cebb69d876b1ed826c1f310b
  test_star_1_f :: GHC.Types.Int -> GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: (\ (n :: GHC.Types.Int) (c :: GHC.Types.Char) ->
                 let {
                   lvl9 :: [GHC.Types.Char]
                   = GHC.Types.: @ GHC.Types.Char c (GHC.Types.[] @ GHC.Types.Char)
                 } in
                 let {
                   s :: [GHC.Types.Char]
                   = case n of wild1 { GHC.Types.I# y ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<# 0# y) of wild {
                       GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                       GHC.Types.True
                       -> letrec {
                            $wxs2 :: GHC.Prim.Int# -> [GHC.Types.Char]
                              {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case ww of ds1 {
                                DEFAULT
                                -> GHC.Types.: @ GHC.Types.Char c ($wxs2 (GHC.Prim.-# ds1 1#))
                                1# -> lvl9 }
                          } in
                          $wxs2 y } }
                 } in
                 GHC.Classes.$fEq[]_$s$c==2
                   (Data.OldList.sortBy
                      @ [GHC.Types.Char]
                      GHC.Classes.$fOrd[]_$s$ccompare1
                      (GHC.Base.map
                         @ (GHC.Base.String, [GHC.Types.Char])
                         @ [GHC.Types.Char]
                         (Data.Tuple.snd @ GHC.Base.String @ [GHC.Types.Char])
                         ((Hare.matchAnywhere
                             @ []
                             @ [GHC.Types.Char]
                             GHC.Base.$fAlternative[]
                             GHC.Base.$fMonad[]
                             (Hare.Star
                                @ [GHC.Types.Char]
                                @ GHC.Types.Char
                                @~ <[GHC.Types.Char]>_N
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N lvl9)))
                            `cast`
                          (HareMonad.N:Hare[0] <[]>_R <[GHC.Types.Char]>_N)
                            s)))
                   (Data.OldList.sortBy
                      @ [GHC.Types.Char]
                      GHC.Classes.$fOrd[]_$s$ccompare1
                      (Tests.UnitTests.test_star_1_go
                         (Data.OldList.inits @ GHC.Types.Char s)))) -}
1f9a3d8f0b0fc557808c246afc1bd1bc
  test_star_1_go :: [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
9935956db9512dc49115e53bc3894d3a
  test_star_2 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_star_8
                   Tests.UnitTests.test_star_6
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
7bc53e068014031567b8a8f511827df0
  test_star_2_f :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.+# ww2 1#
                 } in
                 let {
                   arg :: [[()]]
                   = GHC.Base.map
                       @ (GHC.Base.String, [()])
                       @ [()]
                       (Data.Tuple.snd @ GHC.Base.String @ [()])
                       ((Hare.matchAnywhere
                           @ []
                           @ [()]
                           GHC.Base.$fAlternative[]
                           GHC.Base.$fMonad[]
                           Tests.UnitTests.test_star_7)
                          `cast`
                        (HareMonad.N:Hare[0] <[]>_R <[()]>_N)
                          s)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# y) of wild {
                   GHC.Types.False
                   -> GHC.Classes.$fEq[]_$c==
                        @ [()]
                        Tests.UnitTests.$s$fEq[]
                        arg
                        (GHC.Types.[] @ [()])
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ [()]
                        Tests.UnitTests.$s$fEq[]
                        arg
                        (Tests.UnitTests.$wxs1 y) } }) -}
9ab648fe5601198623d261222dd34888
  test_star_3 :: Test.Tasty.Core.TestTree
  {- Unfolding: (Test.Tasty.Core.SingleTest
                   @ Test.Tasty.QuickCheck.QC
                   Test.Tasty.QuickCheck.$fIsTestQC
                   Tests.UnitTests.test_star_10
                   Tests.UnitTests.test_star_9
                     `cast`
                   (Trans
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Test.QuickCheck.Property.N:Prop[0])))
                        (Trans
                             (Sym (Test.QuickCheck.Property.N:Property[0]))
                             (Sym (Test.Tasty.QuickCheck.N:QC[0]))))) -}
a87c20db23f8debaae6fd7b624f1598a
  test_star_3_f ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (s :: GHC.Base.String) (c :: [GHC.Types.Char]) ->
                 letrec {
                   go :: [GHC.Types.Char] -> Data.Monoid.Any
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Char]) ->
                     case ds of wild {
                       [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                       : y ys
                       -> case GHC.List.elem
                                 @ GHC.Types.Char
                                 GHC.Classes.$fEqChar
                                 y
                                 c of wild1 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } }
                 } in
                 case (Tests.UnitTests.test_star_3_go
                         ((Hare.matchAnywhere
                             @ []
                             @ [GHC.Types.Char]
                             GHC.Base.$fAlternative[]
                             GHC.Base.$fMonad[]
                             (Hare.Star
                                @ [GHC.Types.Char]
                                @ GHC.Types.Char
                                @~ <[GHC.Types.Char]>_N
                                (Hare.Char @ GHC.Types.Char @~ <GHC.Types.Char>_N c)))
                            `cast`
                          (HareMonad.N:Hare[0] <[]>_R <[GHC.Types.Char]>_N)
                            s))
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False -> (go s) `cast` (Data.Monoid.N:Any[0])
                   GHC.Types.True
                   -> case (go s) `cast` (Data.Monoid.N:Any[0]) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
963f94806c58c62f5b83ea5772617887
  test_star_3_go ::
    [(GHC.Base.String, [GHC.Types.Char])] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6ac8d095ef1907367e6c4e5f5cd223f8
  test_star_4 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Test.QuickCheck.Random.QCGen) (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ GHC.Types.Int
                   @ (GHC.Types.Char -> GHC.Types.Bool)
                   GHC.Show.$fShowInt
                   Tests.UnitTests.$stestProperty10
                     `cast`
                   (Trans
                        (<GHC.Types.Char -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <GHC.Types.Char -> GHC.Types.Bool>_N)))
                   Test.QuickCheck.Arbitrary.$fArbitraryInt3
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R))
                   Test.QuickCheck.Arbitrary.$fArbitraryInt_$sshrinkIntegral
                   Tests.UnitTests.test_star_1_f
                   eta
                   eta1) -}
ef5b6957ea648825f6f297ef7459c809
  test_star_5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "star replicate"#) -}
91c52f161542738d6b8819cb95e0a062
  test_star_6 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ GHC.Types.Bool
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_star_2_f
                   eta
                   eta1) -}
787207a96aba488a9b0703190660c6f6
  test_star_7 :: Hare.RE [()]
  {- HasNoCafRefs,
     Unfolding: (Hare.Star @ [()] @ () @~ <[()]>_N (Hare.Fail @ ())) -}
a5024daa24e85d1d149c521011203b6b
  test_star_8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "star fail"#) -}
bfd5391346148841a97c68988ffc4925
  test_star_9 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A)><L,U>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$fTestable(->)2
                   @ [GHC.Types.Char]
                   @ ([GHC.Types.Char] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]1
                   Tests.UnitTests.$stestProperty5
                     `cast`
                   (Trans
                        (<[GHC.Types.Char] -> GHC.Types.Bool>_R
                         ->_R Trans
                                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                            (Test.QuickCheck.Property.N:Prop[0])))
                                  (Sym (Test.QuickCheck.Property.N:Property[0])))
                        (Sym (Test.QuickCheck.Property.N:Testable[0]
                                  <[GHC.Types.Char] -> GHC.Types.Bool>_N)))
                   Tests.UnitTests.$stestProperty2
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R))
                   Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
                   Tests.UnitTests.test_star_3_f
                   eta
                   eta1) -}
"SPEC/Tests.UnitTests $fArbitrary[]_$cshrink @ Char" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                       GHC.Types.Char)
  Test.QuickCheck.Arbitrary.$fArbitrary[]_$cshrink @ GHC.Types.Char
                                                   $dArbitrary
  = Tests.UnitTests.$s$fArbitrary[]_$s$fArbitrary[]_$cshrink
"SPEC/Tests.UnitTests $fEq(,) @ () @ Char" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                       GHC.Types.Char)
                                                           ($dEq :: GHC.Classes.Eq ())
  GHC.Classes.$fEq(,) @ () @ GHC.Types.Char $dEq $dEq1
  = Tests.UnitTests.$s$fEq(,)
"SPEC/Tests.UnitTests $fEq(,) @ Char @ ()" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                       ())
                                                           ($dEq :: GHC.Classes.Eq GHC.Types.Char)
  GHC.Classes.$fEq(,) @ GHC.Types.Char @ () $dEq $dEq1
  = Tests.UnitTests.$s$fEq(,)1
"SPEC/Tests.UnitTests $fEq(,) @ Char @ Char" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                         GHC.Types.Char)
                                                             ($dEq :: GHC.Classes.Eq GHC.Types.Char)
  GHC.Classes.$fEq(,) @ GHC.Types.Char @ GHC.Types.Char $dEq $dEq1
  = Tests.UnitTests.$s$fEq(,)2
"SPEC/Tests.UnitTests $fEq[] @ ()" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                              ())
  GHC.Classes.$fEq[] @ () $dEq = Tests.UnitTests.$s$fEq[]
"SPEC/Tests.UnitTests $fEq[]_$c/= @ ()" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                   ())
  GHC.Classes.$fEq[]_$c/= @ () $dEq
  = Tests.UnitTests.$s$fEq[]_$s$fEq[]_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

